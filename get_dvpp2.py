# -*- coding: utf-8 -*-
"""get_systems.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ytmh-CNLY2pIe9boH_Bd7exFhLSjsvpy

This script is used to create more complicated plants and controllers

Here, I construct the DVPPs used in Verena's ADPFs paper

## DVPP 1
"""

import control as ct
import numpy as np
import sympy as sp

from check_qualification import sympy_to_tf, create_curve
from get_max_reward import simulate_devices_and_limits

# DVPP 1
STATIC_PF = False

power_ratings_dict = {  # in MVA
    'DVPP': 250,
    # 'Hydro': 250,
    'BESS': 30,
    # 'SC': 25
    'PV': 125,
    'Wind': 125
}

pi_params = {}

tau_PV, K_PV = 1.5, 1
tau_WTG, K_WTG = 2, 1
tau_BESS, K_BESS = 0.1, 1
tau_SC = 0.01

pi_params['PV'] = {"kp": 11.9, "ki": 157.9}
pi_params['Wind'] = {"kp": 11.9, "ki": 118}
pi_params['BESS'] = {"kp": 12, "ki": 2370}
pi_params['SC'] = {"kp": 12, "ki": 2370}
pi_params["Hydro"] = {"kp": -0.0796, "ki": -0.09788}

G_PV = ct.tf([K_PV], [tau_PV, 1], inputs=['u'], outputs=['y'])
G_WTG = ct.tf([K_WTG], [tau_WTG, 1], inputs=['u'], outputs=['y'])
G_BESS = ct.tf([K_BESS], [tau_BESS, 1], inputs=['u'], outputs=['y'])
G_SC = ct.tf([1], [tau_SC, 1], inputs=['u'], outputs=['y'])

# # build restricted battery model
# p_BESS = {'tau': tau_BESS}  # maximum energy
# def update(t, x, u, params={}):
#     tau = params.get('tau')
#     x0 = - 1/tau * x[0] + u[0]         # np.clip(u[0], -np.inf, E_max - x[1])
#     x1 = x[0] #+ x[1]                  # energy state
#     return [x0, x1]
# def output(t, x, u, params={}):
#     tau = params.get('tau')
#     return 1/tau * x[0] / (1 + t**(1/2))

# G_BESS = ct.NonlinearIOSystem(
#     update, output, inputs=['u'], outputs=['y'], states=2, params=p_BESS
# )

# hydro
Rg, Rt = 0.03, 0.38
taug, taur, tauw = 0.2, 5, 1
s = sp.symbols('s')

def get_hydro_tf():
    T_hydro = -1/Rg / (taug*s + 1) * (taur*s+1) / (Rt/Rg*taur*s+1) * (1-tauw*s) / (1+1/2*tauw*s)
    return sympy_to_tf(sp.simplify(T_hydro))

T_hydro = get_hydro_tf() # * Gs['Wind'] # add typical delay
T_hydro = ct.tf(T_hydro.num, T_hydro.den, inputs=['u'], outputs=['y'])

# build restricted supercap model
p_SC = {'tau': tau_SC}  # maximum energy
def update(t, x, u, params={}):
    tau = params.get('tau')
    x0 = - 1/tau * x[0] + u[0]         # np.clip(u[0], -np.inf, E_max - x[1])
    x1 = x[0] #+ x[1]                  # energy state
    return [x0, x1]
def output(t, x, u, params={}):
    tau = params.get('tau')
    return 1/tau * x[0] / (1 + t**3)

G_SC = ct.NonlinearIOSystem(
    update, output, inputs=['u'], outputs=['y'], states=2, params=p_SC
)

# main dict: name -> (system, device_type, rating)
IO_dict = {('PV'): (G_PV, 'lpf', power_ratings_dict['PV']),
           ('BESS'): (G_BESS, 'hpf', power_ratings_dict['BESS']),
           ('Wind'): (G_WTG, 'lpf', power_ratings_dict['Wind'])}

# PI and saturation controller parameters
for name in IO_dict.keys():
    #todo fixme
    # pi_params[name]['saturation_limits'] = (-np.inf, np.inf)
    pi_params[name]['saturation_limits'] = (-power_ratings_dict[name], power_ratings_dict[name])

my_names = list(IO_dict.keys())

# FFR
Dp = 1   # set to 1MW (or 1 per unit)
MP_max = 2 *  Dp  # max power for FFR
T_MAX_FFR = 10
require_ffr = {(0, .7): (0, 0), (.7, 5): (1/Dp, 1/Dp), (5, T_MAX_FFR): (1/Dp, 0)}
require_ffr_max = {(0, .7): (0, MP_max), (.7, 5): (MP_max, MP_max), (5, 10): (MP_max, 0)}
ts_ffr_max, input_ffr_max = create_curve(require_ffr_max, t_max=T_MAX_FFR)
_, curve_ffr_min = create_curve(require_ffr, t_max=T_MAX_FFR)

# FCR
ti, ta, = 2, 30
Dp = 1   # set to 1MW (or 1 per unit)
RP_MAX = 1/Dp * 2  # max power for FCR
T_MAX_FCR = 60
require_fcr = {(ti, ta): (0, 1/Dp), (ta, T_MAX_FCR): (1/Dp, 1/Dp)}
require_fcr_max = {(0, ta): (0, RP_MAX), (ta, T_MAX_FCR): (RP_MAX, RP_MAX)}
ts_fcr_max, input_fcr_max = create_curve(require_fcr_max, t_max=T_MAX_FCR)
_, curve_fcr_min = create_curve(require_fcr, t_max=T_MAX_FCR)  # minimum curve

# # test pi params
# from test_pi_contr import test_pi_saturation_individual_vs_dvpp
# test_pi_saturation_individual_vs_dvpp(pi_params, IO_dict)


print('Starting simulation for DVPP2 with devices:', my_names)
print('Using dynamic/static PF:', 'Static' if STATIC_PF else 'Dynamic')
# VALUE, ENERGY, PEAK_POWER, SHAPELY_VALS = simulate_devices_and_limits(
#                               IO_dict=IO_dict,
#                               pi_params=pi_params,
#                               input_service_max=input_fcr_max,
#                               curve_service_min=curve_fcr_min,
#                               title='FCR Response of',
#                               T_MAX=T_MAX_FCR,
#                               save_path='pics/DVPP2/FCR',
#                               STATIC_PF = STATIC_PF
# )
# FFR
VALUE, ENERGY, PEAK_POWER, SHAPELY_VALS = simulate_devices_and_limits(
                              IO_dict=IO_dict,
                              pi_params=pi_params,
                              input_service_max=input_ffr_max,
                              curve_service_min=curve_ffr_min,
                              title='FFR Response of',
                              T_MAX=T_MAX_FFR,
                              save_path='pics/DVPP2/FFR',
                              STATIC_PF = STATIC_PF
)

"""## BESS

From https://www.mdpi.com/1996-1073/14/4/1182 figure 2
"""

# import control as ct
# import numpy as np
# import matplotlib.pyplot as plt
# import sympy as sp

# w_error = ct.summing_junction(['wref', '-w'], 'w_error')

# params = {'kp': 0.5, 'ki': 0.1, 'kd': 0.01}

# def get_pi_controller(params):
#     # old: without saturation
#     return ct.tf(
#         [params['kp'], params['ki']], [1, 0],
#         inputs=['e'], outputs=['u']
#     )

# pi = get_pi_controller(params)

# ct.tf2ss(pi)